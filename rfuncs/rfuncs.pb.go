// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rfuncs.proto

/*
Package rfuncs is a generated protocol buffer package.

It is generated from these files:
	rfuncs.proto

It has these top-level messages:
	Image
	ClipboardContent
	CopyRequest
	CopyReply
	PasteRequest
	PasteReply
	OpenURLRequest
	OpenURLReply
*/
package rfuncs

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ImageFormat int32

const (
	ImageFormat_UNKNOWN ImageFormat = 0
)

var ImageFormat_name = map[int32]string{
	0: "UNKNOWN",
}
var ImageFormat_value = map[string]int32{
	"UNKNOWN": 0,
}

func (x ImageFormat) String() string {
	return proto.EnumName(ImageFormat_name, int32(x))
}
func (ImageFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ClipboardType int32

const (
	ClipboardType_EMPTY  ClipboardType = 0
	ClipboardType_TEXT   ClipboardType = 1
	ClipboardType_RTF    ClipboardType = 2
	ClipboardType_IMAGE  ClipboardType = 3
	ClipboardType_BINARY ClipboardType = 9
)

var ClipboardType_name = map[int32]string{
	0: "EMPTY",
	1: "TEXT",
	2: "RTF",
	3: "IMAGE",
	9: "BINARY",
}
var ClipboardType_value = map[string]int32{
	"EMPTY":  0,
	"TEXT":   1,
	"RTF":    2,
	"IMAGE":  3,
	"BINARY": 9,
}

func (x ClipboardType) String() string {
	return proto.EnumName(ClipboardType_name, int32(x))
}
func (ClipboardType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Image struct {
	Format ImageFormat `protobuf:"varint,1,opt,name=format,enum=rfuncs.ImageFormat" json:"format,omitempty"`
	Data   []byte      `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Image) GetFormat() ImageFormat {
	if m != nil {
		return m.Format
	}
	return ImageFormat_UNKNOWN
}

func (m *Image) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ClipboardContent struct {
	Type ClipboardType `protobuf:"varint,1,opt,name=type,enum=rfuncs.ClipboardType" json:"type,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*ClipboardContent_Text
	//	*ClipboardContent_Image
	//	*ClipboardContent_Binary
	Content isClipboardContent_Content `protobuf_oneof:"content"`
}

func (m *ClipboardContent) Reset()                    { *m = ClipboardContent{} }
func (m *ClipboardContent) String() string            { return proto.CompactTextString(m) }
func (*ClipboardContent) ProtoMessage()               {}
func (*ClipboardContent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isClipboardContent_Content interface {
	isClipboardContent_Content()
}

type ClipboardContent_Text struct {
	Text string `protobuf:"bytes,2,opt,name=text,oneof"`
}
type ClipboardContent_Image struct {
	Image *Image `protobuf:"bytes,3,opt,name=image,oneof"`
}
type ClipboardContent_Binary struct {
	Binary []byte `protobuf:"bytes,4,opt,name=binary,proto3,oneof"`
}

func (*ClipboardContent_Text) isClipboardContent_Content()   {}
func (*ClipboardContent_Image) isClipboardContent_Content()  {}
func (*ClipboardContent_Binary) isClipboardContent_Content() {}

func (m *ClipboardContent) GetContent() isClipboardContent_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ClipboardContent) GetType() ClipboardType {
	if m != nil {
		return m.Type
	}
	return ClipboardType_EMPTY
}

func (m *ClipboardContent) GetText() string {
	if x, ok := m.GetContent().(*ClipboardContent_Text); ok {
		return x.Text
	}
	return ""
}

func (m *ClipboardContent) GetImage() *Image {
	if x, ok := m.GetContent().(*ClipboardContent_Image); ok {
		return x.Image
	}
	return nil
}

func (m *ClipboardContent) GetBinary() []byte {
	if x, ok := m.GetContent().(*ClipboardContent_Binary); ok {
		return x.Binary
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClipboardContent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClipboardContent_OneofMarshaler, _ClipboardContent_OneofUnmarshaler, _ClipboardContent_OneofSizer, []interface{}{
		(*ClipboardContent_Text)(nil),
		(*ClipboardContent_Image)(nil),
		(*ClipboardContent_Binary)(nil),
	}
}

func _ClipboardContent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClipboardContent)
	// content
	switch x := m.Content.(type) {
	case *ClipboardContent_Text:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Text)
	case *ClipboardContent_Image:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Image); err != nil {
			return err
		}
	case *ClipboardContent_Binary:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Binary)
	case nil:
	default:
		return fmt.Errorf("ClipboardContent.Content has unexpected type %T", x)
	}
	return nil
}

func _ClipboardContent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClipboardContent)
	switch tag {
	case 2: // content.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Content = &ClipboardContent_Text{x}
		return true, err
	case 3: // content.image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Image)
		err := b.DecodeMessage(msg)
		m.Content = &ClipboardContent_Image{msg}
		return true, err
	case 4: // content.binary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Content = &ClipboardContent_Binary{x}
		return true, err
	default:
		return false, nil
	}
}

func _ClipboardContent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClipboardContent)
	// content
	switch x := m.Content.(type) {
	case *ClipboardContent_Text:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Text)))
		n += len(x.Text)
	case *ClipboardContent_Image:
		s := proto.Size(x.Image)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClipboardContent_Binary:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Binary)))
		n += len(x.Binary)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CopyRequest struct {
	ClipContent *ClipboardContent `protobuf:"bytes,1,opt,name=clip_content,json=clipContent" json:"clip_content,omitempty"`
}

func (m *CopyRequest) Reset()                    { *m = CopyRequest{} }
func (m *CopyRequest) String() string            { return proto.CompactTextString(m) }
func (*CopyRequest) ProtoMessage()               {}
func (*CopyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CopyRequest) GetClipContent() *ClipboardContent {
	if m != nil {
		return m.ClipContent
	}
	return nil
}

type CopyReply struct {
}

func (m *CopyReply) Reset()                    { *m = CopyReply{} }
func (m *CopyReply) String() string            { return proto.CompactTextString(m) }
func (*CopyReply) ProtoMessage()               {}
func (*CopyReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type PasteRequest struct {
	Accepts []ClipboardType `protobuf:"varint,1,rep,packed,name=accepts,enum=rfuncs.ClipboardType" json:"accepts,omitempty"`
}

func (m *PasteRequest) Reset()                    { *m = PasteRequest{} }
func (m *PasteRequest) String() string            { return proto.CompactTextString(m) }
func (*PasteRequest) ProtoMessage()               {}
func (*PasteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PasteRequest) GetAccepts() []ClipboardType {
	if m != nil {
		return m.Accepts
	}
	return nil
}

type PasteReply struct {
	ClipContent *ClipboardContent `protobuf:"bytes,1,opt,name=clip_content,json=clipContent" json:"clip_content,omitempty"`
}

func (m *PasteReply) Reset()                    { *m = PasteReply{} }
func (m *PasteReply) String() string            { return proto.CompactTextString(m) }
func (*PasteReply) ProtoMessage()               {}
func (*PasteReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PasteReply) GetClipContent() *ClipboardContent {
	if m != nil {
		return m.ClipContent
	}
	return nil
}

type OpenURLRequest struct {
	Url []string `protobuf:"bytes,1,rep,name=url" json:"url,omitempty"`
}

func (m *OpenURLRequest) Reset()                    { *m = OpenURLRequest{} }
func (m *OpenURLRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenURLRequest) ProtoMessage()               {}
func (*OpenURLRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *OpenURLRequest) GetUrl() []string {
	if m != nil {
		return m.Url
	}
	return nil
}

type OpenURLReply struct {
}

func (m *OpenURLReply) Reset()                    { *m = OpenURLReply{} }
func (m *OpenURLReply) String() string            { return proto.CompactTextString(m) }
func (*OpenURLReply) ProtoMessage()               {}
func (*OpenURLReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*Image)(nil), "rfuncs.Image")
	proto.RegisterType((*ClipboardContent)(nil), "rfuncs.ClipboardContent")
	proto.RegisterType((*CopyRequest)(nil), "rfuncs.CopyRequest")
	proto.RegisterType((*CopyReply)(nil), "rfuncs.CopyReply")
	proto.RegisterType((*PasteRequest)(nil), "rfuncs.PasteRequest")
	proto.RegisterType((*PasteReply)(nil), "rfuncs.PasteReply")
	proto.RegisterType((*OpenURLRequest)(nil), "rfuncs.OpenURLRequest")
	proto.RegisterType((*OpenURLReply)(nil), "rfuncs.OpenURLReply")
	proto.RegisterEnum("rfuncs.ImageFormat", ImageFormat_name, ImageFormat_value)
	proto.RegisterEnum("rfuncs.ClipboardType", ClipboardType_name, ClipboardType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RFuncs service

type RFuncsClient interface {
	Copy(ctx context.Context, in *CopyRequest, opts ...grpc.CallOption) (*CopyReply, error)
	Paste(ctx context.Context, in *PasteRequest, opts ...grpc.CallOption) (*PasteReply, error)
	OpenURL(ctx context.Context, in *OpenURLRequest, opts ...grpc.CallOption) (*OpenURLReply, error)
}

type rFuncsClient struct {
	cc *grpc.ClientConn
}

func NewRFuncsClient(cc *grpc.ClientConn) RFuncsClient {
	return &rFuncsClient{cc}
}

func (c *rFuncsClient) Copy(ctx context.Context, in *CopyRequest, opts ...grpc.CallOption) (*CopyReply, error) {
	out := new(CopyReply)
	err := grpc.Invoke(ctx, "/rfuncs.RFuncs/Copy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rFuncsClient) Paste(ctx context.Context, in *PasteRequest, opts ...grpc.CallOption) (*PasteReply, error) {
	out := new(PasteReply)
	err := grpc.Invoke(ctx, "/rfuncs.RFuncs/Paste", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rFuncsClient) OpenURL(ctx context.Context, in *OpenURLRequest, opts ...grpc.CallOption) (*OpenURLReply, error) {
	out := new(OpenURLReply)
	err := grpc.Invoke(ctx, "/rfuncs.RFuncs/OpenURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RFuncs service

type RFuncsServer interface {
	Copy(context.Context, *CopyRequest) (*CopyReply, error)
	Paste(context.Context, *PasteRequest) (*PasteReply, error)
	OpenURL(context.Context, *OpenURLRequest) (*OpenURLReply, error)
}

func RegisterRFuncsServer(s *grpc.Server, srv RFuncsServer) {
	s.RegisterService(&_RFuncs_serviceDesc, srv)
}

func _RFuncs_Copy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RFuncsServer).Copy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rfuncs.RFuncs/Copy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RFuncsServer).Copy(ctx, req.(*CopyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RFuncs_Paste_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RFuncsServer).Paste(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rfuncs.RFuncs/Paste",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RFuncsServer).Paste(ctx, req.(*PasteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RFuncs_OpenURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RFuncsServer).OpenURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rfuncs.RFuncs/OpenURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RFuncsServer).OpenURL(ctx, req.(*OpenURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RFuncs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rfuncs.RFuncs",
	HandlerType: (*RFuncsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Copy",
			Handler:    _RFuncs_Copy_Handler,
		},
		{
			MethodName: "Paste",
			Handler:    _RFuncs_Paste_Handler,
		},
		{
			MethodName: "OpenURL",
			Handler:    _RFuncs_OpenURL_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rfuncs.proto",
}

func init() { proto.RegisterFile("rfuncs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 446 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x93, 0xc1, 0x6f, 0xd3, 0x30,
	0x14, 0xc6, 0x93, 0x25, 0x4d, 0xc8, 0x4b, 0x56, 0x85, 0x47, 0x41, 0x51, 0x4f, 0x95, 0x25, 0xa4,
	0x32, 0xa4, 0x81, 0xba, 0x13, 0xe2, 0x80, 0xb6, 0xd2, 0xd2, 0x02, 0xeb, 0x26, 0x2b, 0x13, 0xec,
	0x84, 0xdc, 0xcc, 0x43, 0x95, 0xb2, 0xc4, 0xa4, 0xae, 0x44, 0xfe, 0x1a, 0xee, 0xfc, 0x95, 0xc8,
	0x8e, 0x53, 0xb5, 0x54, 0x9c, 0xb8, 0xf9, 0xbd, 0xef, 0xf3, 0xa7, 0xdf, 0x7b, 0x4e, 0x20, 0xaa,
	0xee, 0x37, 0x45, 0xb6, 0x3e, 0x15, 0x55, 0x29, 0x4b, 0xf4, 0x9a, 0x8a, 0xcc, 0xa0, 0x33, 0x7f,
	0x60, 0xdf, 0x39, 0xbe, 0x04, 0xef, 0xbe, 0xac, 0x1e, 0x98, 0x4c, 0xec, 0x81, 0x3d, 0xec, 0x8e,
	0x9e, 0x9c, 0x1a, 0xbf, 0x96, 0xa7, 0x5a, 0xa2, 0xc6, 0x82, 0x08, 0xee, 0x1d, 0x93, 0x2c, 0x39,
	0x1a, 0xd8, 0xc3, 0x88, 0xea, 0x33, 0xf9, 0x65, 0x43, 0x3c, 0xce, 0x57, 0x62, 0x59, 0xb2, 0xea,
	0x6e, 0x5c, 0x16, 0x92, 0x17, 0x12, 0x5f, 0x80, 0x2b, 0x6b, 0xc1, 0x4d, 0xe6, 0xd3, 0x36, 0x73,
	0xeb, 0x4b, 0x6b, 0xc1, 0xa9, 0xb6, 0x60, 0x0f, 0x5c, 0xc9, 0x7f, 0x4a, 0x9d, 0x19, 0xcc, 0x2c,
	0xaa, 0x2b, 0x7c, 0x0e, 0x9d, 0x95, 0x02, 0x48, 0x9c, 0x81, 0x3d, 0x0c, 0x47, 0xc7, 0x7b, 0x54,
	0x33, 0x8b, 0x36, 0x2a, 0x26, 0xe0, 0x2d, 0x57, 0x05, 0xab, 0xea, 0xc4, 0x55, 0x48, 0x33, 0x8b,
	0x9a, 0xfa, 0x22, 0x00, 0x3f, 0x6b, 0x60, 0xc8, 0x47, 0x08, 0xc7, 0xa5, 0xa8, 0x29, 0xff, 0xb1,
	0xe1, 0x6b, 0x89, 0x6f, 0x21, 0xca, 0xf2, 0x95, 0xf8, 0x66, 0x64, 0xcd, 0x18, 0x8e, 0x92, 0x03,
	0x46, 0x33, 0x0b, 0x0d, 0x95, 0xdb, 0x14, 0x24, 0x84, 0xa0, 0xc9, 0x12, 0x79, 0x4d, 0xde, 0x41,
	0x74, 0xcd, 0xd6, 0x92, 0xb7, 0xc9, 0xaf, 0xc0, 0x67, 0x59, 0xc6, 0x85, 0x5c, 0x27, 0xf6, 0xc0,
	0xf9, 0xf7, 0xe0, 0xad, 0x8b, 0xcc, 0x01, 0x4c, 0x80, 0xc8, 0xeb, 0xff, 0x03, 0x23, 0xd0, 0xbd,
	0x12, 0xbc, 0xb8, 0xa1, 0x9f, 0x5b, 0x9a, 0x18, 0x9c, 0x4d, 0x95, 0x6b, 0x92, 0x80, 0xaa, 0x23,
	0xe9, 0x42, 0xb4, 0xf5, 0x88, 0xbc, 0x3e, 0xe9, 0x43, 0xb8, 0xf3, 0xca, 0x18, 0x82, 0x7f, 0xb3,
	0xf8, 0xb4, 0xb8, 0xfa, 0xb2, 0x88, 0xad, 0x93, 0xf7, 0x70, 0xbc, 0x07, 0x8d, 0x01, 0x74, 0x26,
	0x97, 0xd7, 0xe9, 0x6d, 0x6c, 0xe1, 0x23, 0x70, 0xd3, 0xc9, 0xd7, 0x34, 0xb6, 0xd1, 0x07, 0x87,
	0xa6, 0xd3, 0xf8, 0x48, 0xa9, 0xf3, 0xcb, 0xf3, 0x0f, 0x93, 0xd8, 0x41, 0x00, 0xef, 0x62, 0xbe,
	0x38, 0xa7, 0xb7, 0x71, 0x30, 0xfa, 0x6d, 0x83, 0x47, 0xa7, 0x0a, 0x1f, 0x5f, 0x83, 0xab, 0x36,
	0x87, 0xdb, 0x0f, 0x6c, 0xe7, 0x4d, 0xfa, 0x8f, 0xf7, 0x9b, 0x6a, 0xb9, 0x16, 0x9e, 0x41, 0x47,
	0x6f, 0x07, 0x7b, 0xad, 0xba, 0xbb, 0xed, 0x3e, 0xfe, 0xd5, 0x6d, 0x2e, 0xbd, 0x01, 0xdf, 0xcc,
	0x88, 0xcf, 0x5a, 0xc3, 0xfe, 0x62, 0xfa, 0xbd, 0x83, 0xbe, 0xbe, 0xba, 0xf4, 0xf4, 0x2f, 0x72,
	0xf6, 0x27, 0x00, 0x00, 0xff, 0xff, 0x8e, 0x99, 0xef, 0x9f, 0x32, 0x03, 0x00, 0x00,
}
